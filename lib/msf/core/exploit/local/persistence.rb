# -*- coding: binary -*-

module Msf
  module Exploit::Local::Persistence
    def initialize(info = {})
      @persistence_service = Rex::Sync::Event.new(auto_reset=false)
      super(
        update_info(
          info,
          'DefaultOptions' => {},
          # https://github.com/rapid7/metasploit-framework/pull/19676#discussion_r1907594308
          'Stance' => Msf::Exploit::Stance::Passive,
          'Passive' => true,
          'Actions' => [
            [ 'INSTALL', { 'Description' => 'Install the persistence' } ],
            [ 'CLEANUP', { 'Description' => 'Cleanup the persistence' } ]
          ],
          'DefaultAction' => 'INSTALL'
        )
      )

      register_advanced_options(
        [
          OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp/']),
          OptBool.new('CleanUpPersistence', [true, 'Remove the installed persistence at the end of the module', false])
        ]
      )
    end

    def exploit
      
      case action.name.upcase
      when 'INSTALL'
        run_as_background = !datastore['DisablePayloadHandler']
        print_warning('Payload handler is disabled, the persistence will be installed only.') unless run_as_background

        # Call the install_persistence function
        # must be declared inside the persistence module
        install_persistence

        @persistence_service.wait if run_as_background

        cleanup_persistence if datastore['CleanUpPersistence']

      when 'CLEANUP'

        # call cleanup_persistence
        # must be declared inside the persistence module
        cleanup_persistence
      end
    end

    def install_persistence
      # to be overloaded by the module
    end

    def cleanup
      # this is done by the action
    end
  end
end